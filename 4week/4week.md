# SOLID 원칙
- S: 단일 책임 원칙
- O: 개발/폐쇄의 원칙
- L: 리스코프 치환 원칙
- I: 인터페이스 분리 원칙
- D: 의존성 역전 원칙

### 단일 책임 원칙
#### 너무 많은 책임을 가진 클래스
- 외부 요소에 의한 영향을 최소화 하고 싶을 때 해결책은 보다 작고 응집력 있는 추상화

#### 책임 분산
- 메서드를 다른 클래스로 분리하여 각 클래스마다 단일 책임을 갖게한다.
- 처리해야 할 로직이 같은 겨우 하나의 클래스에 여러 메서드 추가

### 개방/폐쇄 원칙
- 확장에는 개방, 수정에는 폐쇄
- 새로운 기능 추가하다가 기존 코드 수정은 잘못 디자인 된거임

#### 개방/폐쇄 원칙을 따르지 않을 경우 유지보수의 어려움

#### 확장성을 가진 이벤트 시스템으로 리팩토링
- 개방/폐쇄 원칙을 따르는 디자인을 달성하려면 추상화를 해야 함
- @staticmethod 요걸 이용해서 함수 재구현
- __subclasses__ 를 이용해서 이벤트를 찾는다.

### 리스코프 치환 원칙
- 설계 시 안정성을 유지하기 위해 객체 타입이 유지해야하는 인련의 특성
- 어떤 클래스에서든 클라이언트는 특별한 주의를 기울이지 않고도 하위 타입을 사용할 수 있어야 함

#### 도구를 사용해 LSP 문제 검사
- Mypy, Pylint를 이용해 검출

#### 애매한 LSP 위반 사례
- 하위 클래스는 부모 클래스에 정의된 것보다 사전조건을 엄격하게 만들면 안된다.
- 하위 클래스는 부모 클래스에 정의된 것보다 약한 사후조건을 만들면 안된다.

#### LSP 최종 정리
- 다형성을 강조
- 인터페이스의 메서드가 올바른 계층구조를 갖도록 하여 상속된 클래스가 부모 클래스와 다형성을 유지

### 인터페이스 분리 원칙
- 인터페이스: 객체사 노출하는 메서드의 집합 | 객체사 수신하거나 해석할 수 잇는 모든 메시지가 인터페이스 구성
- 덕 타이핑(duck typing)?-> 예)어떤 새가 오리처럼 걷고 오리처럼 꽥꽥 소리를 낸다면 오리여야함 한다.

### 의존성 역전
- 추상화를 통해 세부 사항에 의존하지 않도록 해야 하지만, 반대로 세부사항은 추상화에 의존
